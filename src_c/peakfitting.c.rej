***************
*** 13,48 ****
  Description:
  
  ****************************************************************************/
- /*
- Copyright (c) 1990-2011 ETH Zurich
- 
- See the file license.txt for copying permission.
- */
- 
  
  #include "ptv.h"
  
- void check_touch (peak *tpeak, int p1, int p2);
  
  
- int peak_fit_new (Tcl_Interp* interp, unsigned char *img, char par_file[], 
- 				  int xmin, int xmax, int ymin, int ymax, target pix[], int nr)
- /*
-   unsigned char *img            image data
-   char     par_file[]           name of parameter file
-   int      xmin,xmax,ymin,ymax  search area
-   target   pix[]                pixel coord array, global
-   int      nr                   image number for display
- */
  /*	newest peak fitting technique for particle coordinate determination  */
  /*	labeling with discontinuity,
  	reunification with distance and profile criteria  */
  {
  	int 		  n_peaks=0;			/* # of peaks detected */
  	int 		  n_wait;				/* size of waitlist for connectivity */
  	int 		  x8[8], y8[8]; 		/* neighbours for connectivity */
  	int 		  p2;					/* considered point number */
- 	int 		  sumg_min, gvthres[4], thres, disco, nxmin,nxmax, nymin,nymax, nnmin, nnmax,rel_disc,dummy;
  	/* parameters for target acceptance */
  	int 		  pnr, sumg, xn, yn;	/* collecting variables for center of gravity */
  	int 		  n_target=0;			/* # of targets detected */
--- 13,40 ----
  Description:
  
  ****************************************************************************/
  
  #include "ptv.h"
  
+ int peak_fit_new ( interp, img, par_file, xmin,xmax,ymin,ymax, pix, nr)
  
+ Tcl_Interp* interp;
+ unsigned char	*img;		       	/* image data */
+ char	       	par_file[];	       	/* name of parameter file */
+ int	       	xmin,xmax,ymin,ymax;	/* search area */
+ target	       	pix[];		       	/* pixel coord array, global */
+ int	       	nr;		       	/* image number for display */
  
  /*	newest peak fitting technique for particle coordinate determination  */
  /*	labeling with discontinuity,
  	reunification with distance and profile criteria  */
  {
+ 
  	int 		  n_peaks=0;			/* # of peaks detected */
  	int 		  n_wait;				/* size of waitlist for connectivity */
  	int 		  x8[8], y8[8]; 		/* neighbours for connectivity */
  	int 		  p2;					/* considered point number */
+   int	      	sumg_min, gvthres[4], thres, disco, nxmin,nxmax, nymin,nymax, nnmin, nnmax;
  	/* parameters for target acceptance */
  	int 		  pnr, sumg, xn, yn;	/* collecting variables for center of gravity */
  	int 		  n_target=0;			/* # of targets detected */
***************
*** 65,72 ****
  
  	/*------------------------------------------------------------------------*/
  
- 	fpp = fopen_rp (par_file);	// replaced fopen_r(), ad holten 12-2012
- 	if (!fpp) return 0;
  	fscanf (fpp, "%d", &gvthres[0]);			/* threshold for binarization 1.image */
  	fscanf (fpp, "%d", &gvthres[1]);			/* threshold for binarization 2.image */
  	fscanf (fpp, "%d", &gvthres[2]);			/* threshold for binarization 3.image */
--- 57,63 ----
  
  	/*------------------------------------------------------------------------*/
  
+   fpp = fopen_r (par_file);
  	fscanf (fpp, "%d", &gvthres[0]);			/* threshold for binarization 1.image */
  	fscanf (fpp, "%d", &gvthres[1]);			/* threshold for binarization 2.image */
  	fscanf (fpp, "%d", &gvthres[2]);			/* threshold for binarization 3.image */
***************
*** 77,92 ****
  	fscanf (fpp, "%d  %d", &nymin, &nymax); 	/* abs, in x, in y		  */
  	fscanf (fpp, "%d", &sumg_min);				/* min. sumg */
  	fscanf (fpp, "%d", &cr_sz); 				/* size of crosses */
- 	fscanf (fpp, "%d", &dummy);
- 	fscanf (fpp, "%d", &dummy);
- 	fscanf (fpp, "%d", &rel_disc);
  	fclose (fpp);
  
  	/* give thres value refering to image number */
  	thres = gvthres[nr];
  
  	/*------------------------------------------------------------------------*/
  	/* allocate memory */
  	/*------------------------------------------------------------------------*/
  
  	label_img = (short*) calloc (imgsize, sizeof(short));
--- 68,82 ----
  	fscanf (fpp, "%d  %d", &nymin, &nymax); 	/* abs, in x, in y		  */
  	fscanf (fpp, "%d", &sumg_min);				/* min. sumg */
  	fscanf (fpp, "%d", &cr_sz); 				/* size of crosses */
  	fclose (fpp);
  
  	/* give thres value refering to image number */
  	thres = gvthres[nr];
  
  	/*------------------------------------------------------------------------*/
+ 
  	/* allocate memory */
+ 
  	/*------------------------------------------------------------------------*/
  
  	label_img = (short*) calloc (imgsize, sizeof(short));
***************
*** 94,113 ****
  	ptr_peak = peaks;
  
  	/*------------------------------------------------------------------------*/
- 	/* 1.: connectivity analysis with peak search and discontinuity criterion */
  	/*------------------------------------------------------------------------*/
  
- 	puts("Searching local maxima, connectivity analysis, peak factor 2 set");
  
- 	//for (i=ymin; i<ymax-1; i++)
- 	//	for (j=xmin; j<xmax; j++) //Beat Lüthi Jan 09 I changed to (i=ymin; i<ymax-1; i++), new:-1
  	
- 	// replaced by the next code to avoid passing image bounds, ad holten 12-2012
- 	if (ymin < 1)     ymin = 1;
- 	if (ymax > imy-1) ymax = imy-1;
  
-     for (i=ymin; i<ymax; i++)
- 		for (j=xmin; j<xmax; j++)
  	{
  		n = i*imx + j;
  
--- 84,99 ----
  	ptr_peak = peaks;
  
  	/*------------------------------------------------------------------------*/
+ 
  	/*------------------------------------------------------------------------*/
  
+   /* 1.: connectivity analysis with peak search and discontinuity criterion */
  
+   /*------------------------------------------------------------------------*/
  	
+   puts("Searching local maxima, connectivity analysis, peak factor 2 set");
  
+   for (i=ymin; i<ymax; i++)  for (j=xmin; j<xmax; j++)
  	{
  		n = i*imx + j;
  
***************
*** 167,184 ****
  				{
  					yn = y8[k];
  					xn = x8[k];
- 					// if (xn<0 || xn>imx || yn<0 || yn>imy) continue;		// Bug repaired, ad holten, 12-2012
- 					if (xn<1 || xn>imx-2 || yn<1 || yn>imy-2) continue;
- 
  					n = imx*yn + xn;
  					if (*(label_img + n) != 0) continue;
  					gv = *(img + n);
  
- 					/* conditions for threshold, discontinuity and peak fitting */
  					if (   (gv > thres)
  						&& (gv <= gvref+disco)
- 						//		removed the image borders test from Beat, ad holten, 2012
- 						//		&& (xn>=xmin)&&(xn<xmax) && (yn>=ymin)&&(yn<ymax-1)//Beat Lüthi Jan 09 I changed to (i=ymin; i<ymax-1; i++), new:-1
  						&& (gvref + disco >= *(img + imx*(yn-1) + xn))
  						&& (gvref + disco >= *(img + imx*(yn+1) + xn))
  						&& (gvref + disco >= *(img + imx*yn + (xn-1)))
--- 153,168 ----
  				{
  					yn = y8[k];
  					xn = x8[k];
+ 		  if (xn<0 || xn>imx || yn<0 || yn>imy)	continue;
  					n = imx*yn + xn;
  					if (*(label_img + n) != 0) continue;
  					gv = *(img + n);
  
+ 		  /* conditions for threshold, discontinuity, image borders */
+ 		  /* and peak fitting */
  					if (   (gv > thres)
+ 			 && (xn>=xmin)&&(xn<xmax) && (yn>=ymin)&&(yn<ymax)
  						&& (gv <= gvref+disco)
  						&& (gvref + disco >= *(img + imx*(yn-1) + xn))
  						&& (gvref + disco >= *(img + imx*(yn+1) + xn))
  						&& (gvref + disco >= *(img + imx*yn + (xn-1)))
***************
*** 191,196 ****
  						)
  					{
  						*(label_img + imx*yn + xn) = n_peaks;
  						waitlist[n_wait].x = xn;	waitlist[n_wait].y = yn;
  						n_wait++;
  					}
--- 175,181 ----
  						)
  					{
  						*(label_img + imx*yn + xn) = n_peaks;
+ 
  						waitlist[n_wait].x = xn;	waitlist[n_wait].y = yn;
  						n_wait++;
  					}
***************
*** 201,218 ****
  				waitlist[n_wait].x = 0;  waitlist[n_wait].y = 0;
  			}	 /*  end of while-loop	*/
  		}
  	}
  
  	/*------------------------------------------------------------------------*/
  	/* 2.:	process label image */
  	/*		(collect data for center of gravity, shape and brightness parameters) */
  	/*		get touch events */
  	/*------------------------------------------------------------------------*/
  
  	puts("Collecting peak data");
  
- 	for (i=ymin; i<ymax; i++)
- 		for (j=xmin; j<xmax; j++)
  	{
  		n = i*imx + j;
  
--- 186,207 ----
  				waitlist[n_wait].x = 0;  waitlist[n_wait].y = 0;
  			}	 /*  end of while-loop	*/
  		}
+ 
  	}
  
+ 
+ 
  	/*------------------------------------------------------------------------*/
+ 
  	/* 2.:	process label image */
  	/*		(collect data for center of gravity, shape and brightness parameters) */
  	/*		get touch events */
+ 
  	/*------------------------------------------------------------------------*/
  
  	puts("Collecting peak data");
  
+   for (i=ymin; i<ymax; i++)  for (j=xmin; j<xmax; j++)
  	{
  		n = i*imx + j;
  
***************
*** 231,270 ****
  			if (i < ptr_peak->ymin)    ptr_peak->ymin = i;
  			if (i > ptr_peak->ymax)    ptr_peak->ymax = i;
  
  			/* get touch events */
- 			// bugs repaired, ad holten 12-2012 i = Y-axis, j = X-axis !!!
- 			// if (i>0 && j>1) 	check_touch (ptr_peak, pnr, *(label_img+n-imx-1));
- 			// if (i>0)			check_touch (ptr_peak, pnr, *(label_img+n-imx));
- 			// if (i>0 && j<imy-1) check_touch (ptr_peak, pnr, *(label_img+n-imx+1));
- 
- 			// if (j>0)			check_touch (ptr_peak, pnr, *(label_img+n-1));
- 			// if (j<imy-1)		check_touch (ptr_peak, pnr, *(label_img+n+1));
- 
- 			// if (i<imx-1 && j>0) check_touch (ptr_peak, pnr, *(label_img+n+imx-1));
- 			// if (i<imx-1)		check_touch (ptr_peak, pnr, *(label_img+n+imx));
- 			// if (i<imx-1 && j<imy-1) check_touch (ptr_peak, pnr, *(label_img+n+imx+1));
  
- 			if (i>0 && j>0) 	check_touch (ptr_peak, pnr, *(label_img+n-imx-1));
  			if (i>0)			check_touch (ptr_peak, pnr, *(label_img+n-imx));
- 			if (i>0 && j<imx-1) check_touch (ptr_peak, pnr, *(label_img+n-imx+1));
  
  			if (j>0)			check_touch (ptr_peak, pnr, *(label_img+n-1));
- 			if (j<imx-1)		check_touch (ptr_peak, pnr, *(label_img+n+1));
  
- 			if (i<imy-1 && j>0) check_touch (ptr_peak, pnr, *(label_img+n+imx-1));
- 			if (i<imy-1)		check_touch (ptr_peak, pnr, *(label_img+n+imx));
- 			if (i<imy-1 && j<imx-1) check_touch (ptr_peak, pnr, *(label_img+n+imx+1));
  		}
  	}
  
  	/*------------------------------------------------------------------------*/
  	/* 3.:	  reunification test: profile and distance */
  	/*------------------------------------------------------------------------*/
  
  	puts("Unifying targets");
  
  	for (i=0; i<n_peaks; i++)
  	{
  		if (peaks[i].n_touch == 0) continue;	/* no touching targets */
  		if (peaks[i].unr != 0)     continue;	/* target already unified */
  
--- 220,252 ----
  			if (i < ptr_peak->ymin)    ptr_peak->ymin = i;
  			if (i > ptr_peak->ymax)    ptr_peak->ymax = i;
  
+ 
  			/* get touch events */
  
+ 	  if (i>0 && j>1)      	check_touch (ptr_peak, pnr, *(label_img+n-imx-1));
  			if (i>0)			check_touch (ptr_peak, pnr, *(label_img+n-imx));
+ 	  if (i>0 && j<imy-1)   check_touch (ptr_peak, pnr, *(label_img+n-imx+1));
  
  			if (j>0)			check_touch (ptr_peak, pnr, *(label_img+n-1));
+ 	  if (j<imy-1)		check_touch (ptr_peak, pnr, *(label_img+n+1));
  
+ 	  if (i<imx-1 && j>0)	check_touch (ptr_peak, pnr, *(label_img+n+imx-1));
+ 	  if (i<imx-1)		check_touch (ptr_peak, pnr, *(label_img+n+imx));
+ 	  if (i<imx-1 && j<imy-1) check_touch (ptr_peak, pnr, *(label_img+n+imx+1));
  		}
  	}
  
  	/*------------------------------------------------------------------------*/
+ 
  	/* 3.:	  reunification test: profile and distance */
+ 
  	/*------------------------------------------------------------------------*/
  
  	puts("Unifying targets");
  
  	for (i=0; i<n_peaks; i++)
  	{
+ 
  		if (peaks[i].n_touch == 0) continue;	/* no touching targets */
  		if (peaks[i].unr != 0)     continue;	/* target already unified */
  
***************
*** 293,317 ****
  
  			/* consider profile dot for dot */
  			/* if any points is by more than disco below profile, do not unify */
- 			if (s12 < 2.0)
- 				unify = 1;
- 			else {
- 				for (unify=1, l=1; l<s12; l++) {
  					intx1 = (int) (x1 + l * (x2 - x1) / s12);
  					inty1 = (int) (y1 + l * (y2 - y1) / s12);
- 					if (rel_disc==0) { //Beat March 2011
  						gv = *(img + inty1*imx + intx1) + disco; 
  						if (gv < (gv1+l*(gv2-gv1)/s12) || gv<gv1 || gv<gv2) unify = 0;
  						if (unify == 0)    break;
  					}
- 					else { // Beat March 2011
- 						gv = *(img + inty1*imx + intx1);
- 						if (gv < (gv1+l*(gv2-gv1)/s12)*(double)disco*0.01) unify = 0;
- 						if (unify == 0)    break;
- 					}
- 				}
- 			}
- 			if (unify == 0)	{
  				non_unified++;
  				continue;
  			}
--- 275,291 ----
  
  			/* consider profile dot for dot */
  			/* if any points is by more than disco below profile, do not unify */
+ 	  if (s12 < 2.0)	unify = 1;
+ 	  else for (unify=1, l=1; l<s12; l++)
+ 	    {
  					intx1 = (int) (x1 + l * (x2 - x1) / s12);
  					inty1 = (int) (y1 + l * (y2 - y1) / s12);
  						gv = *(img + inty1*imx + intx1) + disco; 
  						if (gv < (gv1+l*(gv2-gv1)/s12) || gv<gv1 || gv<gv2) unify = 0;
  						if (unify == 0)    break;
  					}
+ 	  if (unify == 0)
+ 	    {
  				non_unified++;
  				continue;
  			}
***************
*** 331,337 ****
  	}
  
  	/*------------------------------------------------------------------------*/
  	/* 4.:	  process targets */
  	/*------------------------------------------------------------------------*/
  
  	puts("Calculate centers of gravity");
--- 305,313 ----
  	}
  
  	/*------------------------------------------------------------------------*/
+ 
  	/* 4.:	  process targets */
+ 
  	/*------------------------------------------------------------------------*/
  
  	puts("Calculate centers of gravity");
***************
*** 374,418 ****
  		}
  	}
  
  	/* get number of touch events */
  	if (examine == 10)
  	{
  		for (x=0,i=0; i<n_target; i++)
  			x += pix[i].n;
  		x /= n_target;
  		printf ("Average number of pix per target: %6.3f\n", x);
  
  		for (sumg=0,i=0; i<n_peaks; i++)
  			sumg += peaks[i].n_touch;
  		printf ("Number of touch events: %d\n", sumg/2);
  
  		y = 2*n_target*n_target*x/imgsize;
  		printf ("expected number of touch events: %6.0f\n", y);
  	}
  	free (label_img);
  	free (peaks);
  	return (n_target);
  }
  
  
- void check_touch (peak *tpeak, int p1, int p2)
  /* check wether p1, p2 are already marked as touching and mark them otherwise */
  {
  	int    m, done;
  
  	if (p2 == 0)  return;		 /* p2 not labeled */
  	if (p2 == p1) return;		 /* p2 belongs to p1 */
  
  	/* check wether p1, p2 are already marked as touching */
  	for (done=0, m=0; m<tpeak->n_touch; m++)
  		if (tpeak->touch[m] == p2)	done = 1;
  
  	/* mark touch event */
- 	if (done == 0) {
  		tpeak->touch[tpeak->n_touch] = p2;
  		tpeak->n_touch++;
  		/* don't allow for more than 4 touchs */
- 		if (tpeak->n_touch > 3) 
- 			tpeak->n_touch = 3;
  	}
  }
--- 350,412 ----
  		}
  	}
  
+ 
+ 
  	/* get number of touch events */
  	if (examine == 10)
  	{
  		for (x=0,i=0; i<n_target; i++)
+ 	{
  			x += pix[i].n;
+ 	}
  		x /= n_target;
  		printf ("Average number of pix per target: %6.3f\n", x);
  
  		for (sumg=0,i=0; i<n_peaks; i++)
+ 	{
  			sumg += peaks[i].n_touch;
+ 	}
  		printf ("Number of touch events: %d\n", sumg/2);
  
  		y = 2*n_target*n_target*x/imgsize;
  		printf ("expected number of touch events: %6.0f\n", y);
  	}
+ 
  	free (label_img);
  	free (peaks);
+ 
  	return (n_target);
+ 
  }
  
  
+ void check_touch (tpeak, p1, p2)
+ 
+ int    	p1, p2;
+ peak	*tpeak;
+ 
  /* check wether p1, p2 are already marked as touching and mark them otherwise */
+ 
  {
  	int    m, done;
  
+ 
  	if (p2 == 0)  return;		 /* p2 not labeled */
  	if (p2 == p1) return;		 /* p2 belongs to p1 */
  
+ 
  	/* check wether p1, p2 are already marked as touching */
  	for (done=0, m=0; m<tpeak->n_touch; m++)
+     {
  		if (tpeak->touch[m] == p2)	done = 1;
+     }
  
  	/* mark touch event */
+   if (done == 0)
+     {
  		tpeak->touch[tpeak->n_touch] = p2;
  		tpeak->n_touch++;
  		/* don't allow for more than 4 touchs */
+       if (tpeak->n_touch > 3)	tpeak->n_touch = 3;
  	}
  }
